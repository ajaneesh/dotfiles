#+PROPERTY: header-args :tangle ~/.emacs.d/init.el :tangle-dir "~/.emacs.d/"

* Start server process

this is now running as a systemd service

#+begin_src emacs-lisp
;; -*- lexical-binding: t; -*-

(require 'server)
(unless (server-running-p)
  (server-start))

#+end_src

* Startup performance

#+begin_src emacs-lisp

  ;; 1. Performance Improvements
  (defun my/restore-gc-threshold ()
    "Restore garbage collection threshold after startup."
    (setq gc-cons-threshold (* 2 1000 1000)))  ; 2MB

  (add-hook 'emacs-startup-hook #'my/restore-gc-threshold)

  ;; Silence compiler warnings as they can be pretty disruptive
  (setq native-comp-async-report-warnings-errors nil)

  ;; Set the right directory to store the native comp cache
  (add-to-list 'native-comp-eln-load-path (expand-file-name "eln-cache/" user-emacs-directory))

  ;; Auto save and backup settings
  (setq
   backup-by-copying t
   backup-directory-alist '(("." . "~/.emacs.d/backups"))
   delete-old-versions t
   kept-new-versions 6
   kept-old-versions 2
   version-control t)


#+end_src

* Setup package.el and Melpa

#+begin_src emacs-lisp

  ;; Initialize package sources
  (require 'package)

  (setq package-archives '(("melpa" . "https://melpa.org/packages/")
                           ("org" . "https://orgmode.org/elpa/")
                           ("elpa" . "https://elpa.gnu.org/packages/")))

  (package-initialize)
  (unless package-archive-contents
    (package-refresh-contents))

#+end_src

* Some required packages

#+begin_src emacs-lisp

(use-package treemacs-all-the-icons
  :ensure nil)

(use-package which-key
  :ensure nil
  :config
  (which-key-mode))

(use-package ligature
  :ensure nil)

(use-package pyvenv
  :ensure nil)

(use-package all-the-icons
  :ensure nil)

(use-package treemacs-all-the-icons
  :ensure nil)

(use-package htmlize
  :ensure nil)

#+end_src

* Using straight.el for package management

#+begin_src emacs-lisp
  (unless (featurep 'straight)
    ;; Bootstrap straight.el
    (defvar bootstrap-version)
    (let ((bootstrap-file
           (expand-file-name "straight/repos/straight.el/bootstrap.el" user-emacs-directory))
          (bootstrap-version 5))
      (unless (file-exists-p bootstrap-file)
        (with-current-buffer
            (url-retrieve-synchronously
             "https://raw.githubusercontent.com/raxod502/straight.el/develop/install.el"
             'silent 'inhibit-cookies)
          (goto-char (point-max))
          (eval-print-last-sexp)))
      (load bootstrap-file nil 'nomessage)))

  ;; Use straight.el for use-package expressions
  (straight-use-package 'use-package)

#+end_src

* SSH Tunnel Configuration (need external library that uses pem key and secrets)
** TODO This is only for the ssh tunneling.  I need to turn this into a module that can be loaded from git.  Having it in this folder will mean that it cannot be made available to others in a reproducible fashion

#+begin_src emacs-lisp

  ;; Add my library path to load-path
  (push "~/lib/elisp/" load-path)

#+end_src

** Need to externalize secrets and put this in a github repo as a package so that this can be loaded from other machines without having to copy it around

#+begin_src emacs-lisp

  (require 'ssh-tunnel-manager)

  ;; Optional: setup default keybindings
  (ssh-tunnel-setup-default-keybindings)


#+end_src

* Basic UI Configuration

#+begin_src emacs-lisp

  (setq inhibit-startup-message t)

  (scroll-bar-mode -1)        ; Disable visible scrollbar
  (tool-bar-mode -1)          ; Disable the toolbar
  (tooltip-mode -1)           ; Disable tooltips
  (set-fringe-mode 10)        ; Give some breathing room

  (menu-bar-mode -1)            ; Disable the menu bar

  ;; Set up the visible bell
  (setq visible-bell t)

  (column-number-mode)
  ;; (global-display-line-numbers-mode t)
  (global-hl-line-mode 1)

  ;; Set frame transparency
  ;; (set-frame-parameter (selected-frame) 'alpha efs/frame-transparency)
  ;; (add-to-list 'default-frame-alist `(alpha . ,efs/frame-transparency))
  ;; (set-frame-parameter (selected-frame) 'fullscreen 'maximized)
  ;; (add-to-list 'default-frame-alist '(fullscreen . maximized))

  ;;
  ;; Disable line numbers for some modes
  (dolist (mode '(org-mode-hook
                  term-mode-hook
                  shell-mode-hook
                  treemacs-mode-hook
                  eshell-mode-hook))
    (add-hook mode (lambda () (display-line-numbers-mode 0))))

  (setq make-backup-files nil) ; stop creating backup~ files
  (setq auto-save-default nil) ; stop creating #autosave# files
  (setq cider-save-file-on-load nil)

  ;; 7. Better Window Management
  (use-package windmove
    :ensure nil
    :config
    (windmove-default-keybindings 'super))

  ;; Ace-window - for more complex window management
  (use-package ace-window
    :ensure nil
    :bind (("M-o" . ace-window))
    :custom
    (aw-keys '(?a ?s ?d ?f ?g ?h ?j ?k ?l)) ; Use letters instead of numbers
    :config
    (ace-window-display-mode 1)) ; Optionally show persistent window labels

#+end_src

* Get =evil-mode= up and running ASAP so that we dont have to struggle with emacs editing controls

#+begin_src emacs-lisp

    (use-package undo-tree
      :ensure nil
      :config
      (setq undo-tree-auto-save-history nil)
      (global-undo-tree-mode 1))


    (use-package evil
      :init
      (setq evil-want-integration t)
      (setq evil-want-keybinding nil)
      (setq evil-want-C-u-scroll t)
      (setq evil-want-C-i-jump nil)
      (setq evil-respect-visual-line-mode t)
      (setq evil-undo-system 'undo-tree)

      :config
      (evil-mode 1)

      ;; Set Emacs state modes
      (dolist (mode '(custom-mode
                      eshell-mode
                      git-rebase-mode
                      erc-mode
                      circe-server-mode
                      circe-chat-mode
                      circe-query-mode
                      sauron-mode
                      term-mode))
        (add-to-list 'evil-emacs-state-modes mode))

      (define-key evil-insert-state-map (kbd "C-g") 'evil-normal-state)
      (define-key evil-insert-state-map (kbd "C-h") 'evil-delete-backward-char-and-join)
      ;; (define-key evil-normal-state-map (kbd "C-<left>") 'backward-word)
      ;; (define-key evil-normal-state-map (kbd "C-<right>") 'forward-word)
      ;; Clear the binding of C-k so that it doesn't conflict with Corfu
      (define-key evil-insert-state-map (kbd "C-k") nil)

      ;; Use visual line motions even outside of visual-line-mode buffers
      (evil-global-set-key 'motion "j" 'evil-next-visual-line)
      (evil-global-set-key 'motion "k" 'evil-previous-visual-line)
      (evil-set-initial-state 'messages-buffer-mode 'normal)
      (evil-set-initial-state 'dashboard-mode 'normal))

    (use-package evil-collection
      :after evil
      :ensure nil
      :config
      (evil-collection-init '(not python)))

    ;; Example: ysiw"  surround word with quotes
    ;;          ds"    delete surrounding quotes
    ;;          cs'   change surrounding quotes to single quotes
    (use-package evil-surround
      :ensure nil
      :config
      (global-evil-surround-mode 1))

    (use-package evil-commentary
    :ensure nil
    :config
    (evil-commentary-mode))

      (use-package evil-matchit
      :ensure nil
      :config
      (global-evil-matchit-mode 1))

(use-package expand-region
  :ensure nil
  :config
  ;; Define for all programming modes
  (define-key prog-mode-map (kbd "C-{") 'er/expand-region)
  
  ;; If using Evil, add Evil bindings for all programming modes
  (evil-define-key '(normal visual) prog-mode-map
    (kbd "C-{") 'er/expand-region))


    ;; Org block navigation
    (with-eval-after-load 'org
      (define-key org-mode-map (kbd "C-c n") #'org-next-block)
      (define-key org-mode-map (kbd "C-c p") #'org-previous-block) )

#+end_src

* Python configuration

#+begin_src emacs-lisp

;; Remove ELPA python package from load path
(setq load-path 
      (cl-remove-if
       (lambda (path)
         (string-match-p "python-0\\.28" path))
       load-path))

;; Force load the built-in python.el first
(load "/nix/store/ypkhlc24d7skgal25f58bnnbp9rp49li-emacs-29.4/share/emacs/29.4/lisp/progmodes/python")

;; TreeSit and Python configuration
(use-package treesit
  :ensure nil
  :config
  (setq treesit-language-source-alist
        '((python "https://github.com/tree-sitter/tree-sitter-python")))

  (when (treesit-available-p)
    ;; Install grammar if needed
    (unless (treesit-language-available-p 'python)
      (treesit-install-language-grammar 'python))
    
    ;; Set up python-ts-mode
    (defvar python-ts-mode-map (make-sparse-keymap))
    (add-to-list 'major-mode-remap-alist
                 '(python-mode . python-ts-mode))
    (add-to-list 'auto-mode-alist '("\\.py\\'" . python-ts-mode))))

;; LSP and development tools configuration
(use-package lsp-mode
  :hook ((python-ts-mode . lsp-deferred))
  :custom
  (lsp-idle-delay 0.5)
  (lsp-log-io nil)
  (lsp-completion-provider :capf)
  (lsp-keymap-prefix "C-c l")
  :config
  (lsp-enable-which-key-integration t)
  (setq lsp-pyls-plugins-pylint-enabled t)
  (setq lsp-pyls-plugins-autopep8-enabled nil)
  (setq lsp-pyls-plugins-yapf-enabled t)
  (setq lsp-pyls-plugins-pycodestyle-enabled t)
  (setq lsp-pyright-use-library-code-for-types t)
  (setq lsp-pyright-diagnostic-mode "workspace")
  (setq lsp-pyright-auto-import-completions t))

(use-package lsp-pyright
  :ensure nil
  :hook (python-ts-mode . (lambda ()
                            (require 'lsp-pyright)
                            (lsp-deferred))))

;; Development tools
(use-package python-black
  :after python
  :hook (python-ts-mode . python-black-on-save-mode))

(use-package py-isort
  :hook (python-ts-mode . py-isort-before-save))

;; Environment Management
(use-package pyvenv
  :config
  (pyvenv-mode 1))

;; Initialize evil-collection for python after everything is set up
(with-eval-after-load 'evil-collection
  (when (treesit-available-p)
    (evil-collection-init '(python))))



;; Python development keybindings
(add-hook 'python-ts-mode-hook
	  (lambda ()
	    (let ((map python-ts-mode-map))
	      (define-key map (kbd "C-c C-f") 'python-black-buffer)
	      (define-key map (kbd "C-c C-i") 'py-isort-buffer)
	      (define-key map (kbd "C-c d") 'lsp-ui-doc-show)
	      (define-key map (kbd "C-c C-d") 'lsp-find-definition)
	      (define-key map (kbd "C-c C-r") 'lsp-find-references)
	      (define-key map (kbd "M-.") 'lsp-find-definition)
	      (define-key map [f3] 'lsp-find-definition)
	      (define-key map [f4] 'my/smart-find-references)
	      (define-key map [M-left] 'xref-go-back))))


;; Override Evil keybindings for Python
(with-eval-after-load 'evil
  (evil-define-key '(normal insert visual) python-ts-mode-map 
    (kbd "M-.") 'lsp-find-definition
    (kbd "M-,") 'xref-go-back))

#+end_src

* =org-mode= base configuration

#+begin_src emacs-lisp

;; TODO: Mode this to another section
(setq-default fill-column 80)

;; Org-mode specific settings
(use-package org
  :ensure nil
  :custom
  (org-startup-indented t)
  (org-startup-folded t)
  (org-log-done 'time)
  (org-agenda-start-on-weekday nil)
  (org-hide-emphasis-markers t)
  (org-fontify-quote-and-verse-blocks t)
  (org-fontify-whole-heading-line t)
  (org-hide-leading-stars t)
  (org-pretty-entities t)
  (org-ellipsis "…")
  )

(use-package org-superstar
  :ensure nil
  :after org
  :hook (org-mode . org-superstar-mode)
  :custom
  (org-superstar-headline-Bullets-list '("◉" "○" "●" "○" "●" "○" "●")))

;; This is needed as of Org 9.2
(use-package org-tempo
  :config
  (add-to-list 'org-structure-template-alist '("sh" . "src sh"))
  (add-to-list 'org-structure-template-alist '("el" . "src emacs-lisp"))
  (add-to-list 'org-structure-template-alist '("li" . "src lisp"))
  (add-to-list 'org-structure-template-alist '("sc" . "src scheme"))
  (add-to-list 'org-structure-template-alist '("ts" . "src typescript"))
  (add-to-list 'org-structure-template-alist '("py" . "src python"))
  (add-to-list 'org-structure-template-alist '("go" . "src go"))
  (add-to-list 'org-structure-template-alist '("yaml" . "src yaml"))
  (add-to-list 'org-structure-template-alist '("json" . "src json")))

(with-eval-after-load 'org
  (setq org-src-preserve-indentation nil)
  (setq org-edit-src-content-indentation 0)
  (setq org-src-tab-acts-natively t))

(setq org-agenda-files '("~/org" "~/org/roam"))

(with-eval-after-load 'evil
    (evil-define-key '(normal insert) org-mode-map
      (kbd "S-<right>") 'org-shiftright))
#+end_src

* =org-roam= and =org-ui= configuration

#+begin_src emacs-lisp 

(use-package org-roam
  :ensure nil
  :custom
  (org-roam-directory (file-truename "~/org/roam/")) ;; Set your preferred directory
  (org-roam-completion-everywhere t)
  (org-roam-capture-templates
   '(("d" "default" plain
      "%?"
      :if-new (file+head "%<%Y%m%d%H%M%S>-${slug}.org" "#+title: ${title}\n")
      :unnarrowed t)))
  :bind (("C-c n l" . org-roam-buffer-toggle)
         ("C-c n f" . org-roam-node-find)
         ("C-c n i" . org-roam-node-insert)
         :map org-mode-map
         ("C-M-i" . completion-at-point))
  :config
  (org-roam-db-autosync-mode))

(use-package org-roam-ui
  :ensure nil
  :after org-roam
  :custom
  (org-roam-ui-sync-theme t)
  (org-roam-ui-follow t)
  (org-roam-ui-update-on-save t)
  (org-roam-ui-open-on-start t))

#+end_src

* =org-mode= wrapping
** Automatic wrapping: Enable auto-fill-mode for automatic wrapping as you type:

#+begin_src emacs-lisp
  ;; (add-hook 'org-mode-hook 'auto-fill-mode)
#+end_src
  
** Visual wrapping (doesn't modify text, just displays it wrapped):

#+begin_src emacs-lisp
  ;; (add-hook 'org-mode-hook 'visual-line-mode)
#+end_src

** Auto wrap to window size

#+begin_src emacs-lisp

  (defun my/set-org-visual-wrap ()
    "Enable visual line wrapping for org-mode."
    (visual-line-mode 1)             
    (setq word-wrap t)               
    (setq truncate-lines nil))       

    (add-hook 'org-mode-hook 'my/set-org-visual-wrap)
  
#+end_src

* Buffer customizations (prot tips to ensure they open in specific windows)
Need to borrow some useful configuration to control mini buffer from Prot's youtube video.  I have deferred this for a while.  Once i live with my configuration for a while i will be in a better position to understand what exactly i am missing.  Better not start with what someone feels is a good way to configure buffers. 

* Project.el configuration

#+begin_src emacs-lisp

  ;; Project configuration
  (use-package project
    :ensure nil  ; built into Emacs
    :config
    ;; Custom project root finding function
    (defun my/project-try-deps-edn (dir)
      "Return project instance if DIR has deps.edn file."
      (let ((proj-file (locate-dominating-file dir "deps.edn")))
        (if proj-file
            (cons 'deps-edn proj-file)
          nil)))
    
    (defun my/project-try-project-clj (dir)
      "Return project instance if DIR has project.clj file."
      (let ((proj-file (locate-dominating-file dir "project.clj")))
        (if proj-file
            (cons 'lein proj-file)
          nil)))
    
    ;; Define how to get root for deps.edn projects
    (cl-defmethod project-root ((project (head deps-edn)))
      (cdr project))
    
    ;; Add Clojure project detection
    (add-hook 'project-find-functions #'my/project-try-deps-edn)
    (add-hook 'project-find-functions #'my/project-try-project-clj))

  (setq project-vc-extra-root-markers '("pyproject.toml" "setup.py" ".git" "requirements.txt"))

  ;; Convenient keybindings for project.el
  (global-set-key (kbd "C-c p f") #'project-find-file)
  (global-set-key (kbd "C-c p d") #'project-find-dir)
  (global-set-key (kbd "C-c p b") #'project-switch-to-buffer)
  (global-set-key (kbd "C-c p p") #'project-switch-project)
  (global-set-key (kbd "C-c p s") #'project-shell)
  (global-set-key (kbd "C-c p g") #'project-find-regexp)
  (global-set-key (kbd "C-c p e") #'project-eshell)

  (setq project-additional-project-dirs 
        '("~/automation_scripts" "pyprojects"))

#+end_src

* Vertico configuration

#+begin_src emacs-lisp
  ;; Enable vertico
  (use-package vertico
    :ensure nil
    :custom
    ;; (vertico-scroll-margin 0) ;; Different scroll margin
    ;; (vertico-count 20) ;; Show more candidates
    (vertico-resize t) ;; Grow and shrink the Vertico minibuffer
    (vertico-cycle t) ;; Enable cycling for `vertico-next/previous'
    :init
    (vertico-mode))

  ;; Persist history over Emacs restarts. Vertico sorts by history position.
  (use-package savehist
    :ensure nil
    :init
    (savehist-mode))  
#+end_src

* Marginalia configuration

#+begin_src emacs-lisp

  ;; Enable rich annotations using the Marginalia package
  (use-package marginalia
    :ensure nil
    ;; Bind `marginalia-cycle' locally in the minibuffer.  To make the binding
    ;; available in the *Completions* buffer, add it to the
    ;; `completion-list-mode-map'.
    :bind (:map minibuffer-local-map
                ("M-A" . marginalia-cycle))

    ;; The :init section is always executed.
    :init

    ;; Marginalia must be activated in the :init section of use-package such that
    ;; the mode gets enabled right away. Note that this forces loading the
    ;; package.
    (marginalia-mode))
#+end_src

* Consult configuration

#+begin_src emacs-lisp

  ;; Example configuration for Consult
  (use-package consult
    :ensure nil
    ;; Replace bindings. Lazily loaded by `use-package'.
    :bind (;; C-c bindings in `mode-specific-map'
           ("C-c M-x" . consult-mode-command)
           ("C-c h" . consult-history)
           ("C-c k" . consult-kmacro)
           ("C-c m" . consult-man)
           ("C-c i" . consult-info)
           ([remap Info-search] . consult-info)
           ;; C-x bindings in `ctl-x-map'
           ("C-x M-:" . consult-complex-command)     ;; orig. repeat-complex-command
           ("C-x b" . consult-buffer)                ;; orig. switch-to-buffer
           ("C-x 4 b" . consult-buffer-other-window) ;; orig. switch-to-buffer-other-window
           ("C-x 5 b" . consult-buffer-other-frame)  ;; orig. switch-to-buffer-other-frame
           ("C-x t b" . consult-buffer-other-tab)    ;; orig. switch-to-buffer-other-tab
           ("C-x r b" . consult-bookmark)            ;; orig. bookmark-jump
           ("C-x p b" . consult-project-buffer)      ;; orig. project-switch-to-buffer
           ;; Custom M-# bindings for fast register access
           ("M-#" . consult-register-load)
           ("M-'" . consult-register-store)          ;; orig. abbrev-prefix-mark (unrelated)
           ("C-M-#" . consult-register)
           ;; Other custom bindings
           ("M-y" . consult-yank-pop)                ;; orig. yank-pop
           ;; M-g bindings in `goto-map'
           ("M-g e" . consult-compile-error)
           ("M-g f" . consult-flymake)               ;; Alternative: consult-flycheck
           ("M-g g" . consult-goto-line)             ;; orig. goto-line
           ("M-g M-g" . consult-goto-line)           ;; orig. goto-line
           ("M-g o" . consult-outline)               ;; Alternative: consult-org-heading
           ("M-g m" . consult-mark)
           ("M-g k" . consult-global-mark)
           ("M-g i" . consult-imenu)
           ("M-g I" . consult-imenu-multi)
           ;; M-s bindings in `search-map'
           ("M-s d" . consult-find)                  ;; Alternative: consult-fd
           ("M-s c" . consult-locate)
           ("M-s g" . consult-grep)
           ("M-s G" . consult-git-grep)
           ("M-s r" . consult-ripgrep)
           ("M-s l" . consult-line)
           ("M-s L" . consult-line-multi)
           ("M-s k" . consult-keep-lines)
           ("M-s u" . consult-focus-lines)
           ;; Isearch integration
           ("M-s e" . consult-isearch-history)
           :map isearch-mode-map
           ("M-e" . consult-isearch-history)         ;; orig. isearch-edit-string
           ("M-s e" . consult-isearch-history)       ;; orig. isearch-edit-string
           ("M-s l" . consult-line)                  ;; needed by consult-line to detect isearch
           ("M-s L" . consult-line-multi)            ;; needed by consult-line to detect isearch
           ;; Minibuffer history
           :map minibuffer-local-map
           ("M-s" . consult-history)                 ;; orig. next-matching-history-element
           ("M-r" . consult-history))                ;; orig. previous-matching-history-element

    ;; Enable automatic preview at point in the *Completions* buffer. This is
    ;; relevant when you use the default completion UI.
    :hook (completion-list-mode . consult-preview-at-point-mode)

    ;; The :init configuration is always executed (Not lazy)
    :init

    ;; Optionally configure the register formatting. This improves the register
    ;; preview for `consult-register', `consult-register-load',
    ;; `consult-register-store' and the Emacs built-ins.
    (setq register-preview-delay 0.5
          register-preview-function #'consult-register-format)

    ;; Optionally tweak the register preview window.
    ;; This adds thin lines, sorting and hides the mode line of the window.
    (advice-add #'register-preview :override #'consult-register-window)

    ;; Use Consult to select xref locations with preview
    (setq xref-show-xrefs-function #'consult-xref
          xref-show-definitions-function #'consult-xref)

    ;; Configure other variables and modes in the :config section,
    ;; after lazily loading the package.
    :config

    ;; Optionally configure preview. The default value
    ;; is 'any, such that any key triggers the preview.
    ;; (setq consult-preview-key 'any)
    ;; (setq consult-preview-key "M-.")
    ;; (setq consult-preview-key '("S-<down>" "S-<up>"))
    ;; For some commands and buffer sources it is useful to configure the
    ;; :preview-key on a per-command basis using the `consult-customize' macro.
    (consult-customize
     consult-theme :preview-key '(:debounce 0.2 any)
     consult-ripgrep consult-git-grep consult-grep
     consult-bookmark consult-recent-file consult-xref
     consult--source-bookmark consult--source-file-register
     consult--source-recent-file consult--source-project-recent-file
     ;; :preview-key "M-."
     :preview-key '(:debounce 0.4 any))

    ;; Optionally configure the narrowing key.
    ;; Both < and C-+ work reasonably well.
    (setq consult-narrow-key "<") ;; "C-+"

    ;; Optionally make narrowing help available in the minibuffer.
    ;; You may want to use `embark-prefix-help-command' or which-key instead.
    ;; (keymap-set consult-narrow-map (concat consult-narrow-key " ?") #'consult-narrow-help)
    )

  (use-package consult-lsp
    :ensure nil
    
    )

  (use-package consult-project-extra
    :ensure nil
    :bind
    (("C-c p f" . consult-project-extra-find)
     ("C-c p o" . consult-project-extra-find-other-window)))

#+end_src
    
* Consult - Custom extensions

#+begin_src emacs-lisp

  (defun my/consult-find-across-projects ()
    "Find files across all known projects."
    (interactive)
    (let* ((projects (project-known-project-roots))
           (dirs (cl-remove-if-not #'file-exists-p projects)))
      (consult-find dirs)))

  ;; Bind it to a key
  (global-set-key (kbd "C-c p F") #'my/consult-find-across-projects)
  (global-set-key (kbd "M-s F") #'my/consult-find-across-projects)

#+end_src

* =dgrep= for search and replace across files (not buffers)
this will allow us to make changes across multiple unopened files in file system within a project using a combination of consult-ripgrep, embark-act and wgrep-change-to-wgrep-mode

#+begin_src emacs-lisp

(use-package wgrep
  :ensure nil
  :config
  ;; Allow editing in `grep` buffers
  (setq wgrep-auto-save-buffer t) ; Automatically save changes when finishing edits
  (setq wgrep-change-readonly-file t) ; Allow editing read-only files

  ;; Keybindings for `wgrep` mode
  (define-key wgrep-mode-map (kbd "C-c C-c") 'wgrep-finish-edit) ; Save changes
  (define-key wgrep-mode-map (kbd "C-c C-k") 'wgrep-abort-changes)) ; Abort changes

(defun my/embark-collect-wgrep-mode ()
  "Enable `wgrep` mode in the current `embark-collect` buffer."
  (interactive)
  (message "Enabling wgrep-mode...")
  (wgrep-change-to-wgrep-mode)) ; Enable `wgrep` mode

(with-eval-after-load 'embark
  ;; Bind `e` to enable `wgrep` mode in `embark-collect` buffers
  (evil-define-key 'normal embark-collect-mode-map (kbd "e") 'my/embark-collect-wgrep-mode))

(with-eval-after-load 'evil
  ;; Ensure `C-c C-c` works in `wgrep-mode` with `evil-mode`
  (evil-define-key 'normal wgrep-mode-map (kbd "C-c C-c") 'wgrep-finish-edit))

#+end_src

* Embark configuration

#+begin_src emacs-lisp

(use-package embark
  :ensure nil
  :bind
  (("C-." . embark-act)         ;; pick some comfortable binding
   ("C->" . embark-become)      ;; pick some comfortable binding
   ("C-;" . embark-dwim)        ;; good alternative: M-.
   ("C-h B" . embark-bindings)) ;; alternative for `describe-bindings'

  :init

  ;; Optionally replace the key help with a completing-read interface
  (setq prefix-help-command #'embark-prefix-help-command)

  ;; Show the Embark target at point via Eldoc. You may adjust the
  ;; Eldoc strategy, if you want to see the documentation from
  ;; multiple providers. Beware that using this can be a little
  ;; jarring since the message shown in the minibuffer can be more
  ;; than one line, causing the modeline to move up and down:

  ;; (add-hook 'eldoc-documentation-functions #'embark-eldoc-first-target)
  ;; (setq eldoc-documentation-strategy #'eldoc-documentation-compose-eagerly)

  :config

  ;; Hide the mode line of the Embark live/completions buffers
  (add-to-list 'display-buffer-alist
               '("\\`\\*Embark Collect \\(Live\\|Completions\\)\\*"
                 nil
                 (window-parameters (mode-line-format . none)))))
;; Consult users will also want the embark-consult package.
(use-package embark-consult
  :ensure nil ; only need to install it, embark loads it after consult if found
  :hook
  (embark-collect-mode . consult-preview-at-point-mode))

#+end_src

* Orderless configuration

#+begin_src emacs-lisp

  (use-package orderless
    :ensure nil
    :custom
    (completion-styles '(orderless basic))
    (completion-category-defaults nil)
    (completion-category-overrides '((file (styles basic partial-completion)))))  
#+end_src

* Cape Configuration

#+begin_src emacs-lisp

;; diabling company as we have corfu and cape for completions.
;; (global-company-mode -1)

;; Completion Setup with Cape and Corfu
(use-package cape
  :ensure nil
  :init
  ;; Add useful defaults completion sources from Cape
  (add-to-list 'completion-at-point-functions #'cape-file)
  (add-to-list 'completion-at-point-functions #'cape-dabbrev)
  :hook (python-ts-mode . (lambda ()
                            (add-to-list 'completion-at-point-functions #'cape-file)
                            (add-to-list 'completion-at-point-functions #'cape-dabbrev)))
  :config
  ;; Define a list of completion sources
  (setq cape-completion-sources
        '(cape-file
          cape-dabbrev
          cape-history
          cape-keyword
          cape-tex
          cape-abbrev))
  
  ;; Add all sources to completion-at-point-functions
  (dolist (source cape-completion-sources)
    (add-to-list 'completion-at-point-functions source)))

#+end_src

* Python test configuration

#+begin_src emacs-lisp 

(use-package pytest
  :ensure nil
  :after python
  :commands (pytest-one
    	     pytest-pdb-one
    	     pytest-all
    	     pytest-module
    	     pytest-last-failed)
  :config
  (setq pytest-cmd-flags "--cov=app --cov-report=term --cov-report=html")
  :bind (:map python-mode-map
              ("C-c t f" . pytest-file)
              ("C-c t t" . pytest-function)
              ("C-c t a" . pytest-all)
              ("C-c t m" . pytest-module)
              ("C-c t r" . pytest-repeat)))

(use-package coverage
  :ensure nil
  :config
  (setq coverage-path ".coverage")
  :bind (:map python-mode-map
              ("C-c c" . coverage-mode)))

(use-package flycheck
  :ensure nil
  :init (global-flycheck-mode)
  :config
  (setq flycheck-python-pylint-executable "pylint")
  (setq flycheck-python-flake8-executable "flake8"))

;; More detailed coverage setup
(defun setup-python-coverage ()
  "Set up coverage visualization for Python projects."
  (interactive)
  (let ((coverage-html-dir (concat (projectile-project-root) "htmlcov")))
    (if (file-exists-p coverage-html-dir)
        (browse-url (concat "file://" coverage-html-dir "/index.html"))
      (message "No coverage report found. Run tests with coverage first."))))

(defun run-pytest-with-coverage ()
  "Run pytest with coverage on the current project."
  (interactive)
  (let ((default-directory (projectile-project-root)))
    (compile "python -m pytest --cov=. --cov-report=html")))

(global-set-key (kbd "C-c C-t") 'run-pytest-with-coverage)
(global-set-key (kbd "C-c C-v") 'setup-python-coverage)


#+end_src

* Python BDD Specific configuration

#+begin_src emacs-lisp 

(use-package feature-mode
  :ensure nil)
(add-to-list 'auto-mode-alist '("\.feature$" . feature-mode))


#+end_src

* Corfu Configuration

#+begin_src emacs-lisp

  (use-package corfu
    :ensure nil
    :custom
    (corfu-auto t)  ; Enable auto completion
    (corfu-auto-delay 0.2)
    (corfu-auto-prefix 2)
    (corfu-preview-current nil)
    (corfu-quit-at-boundary 'separator)

    :init
    (global-corfu-mode)

    :hook
    ((clojure-mode . corfu-mode)
     (cider-repl-mode . corfu-mode)
     (python-ts-mode . corfu-mode)))

  ;; Optional: Enable Corfu in the minibuffer
  (defun corfu-enable-in-minibuffer ()
    "Enable Corfu in the minibuffer if `completion-at-point' is bound."
    (when (where-is-internal #'completion-at-points (list (current-local-map)))
      (corfu-mode 1)))

  (add-hook 'minibuffer-setup-hook #'corfu-enable-in-minibuffer)
#+end_src

* =magit= to start working with Git.

* Clojure support

#+begin_src emacs-lisp

  (use-package clojure-mode
    :ensure nil
    :custom
    (clojure-align-forms-automatically t))

  (use-package cider
    :ensure nil
    :custom
    (cider-repl-pop-to-buffer-on-connect nil)
    (cider-save-file-on-load t)
    (cider-save-file-on-load t)
    :config

    (setq cider-repl-display-help-banner nil)
    (setq cider-print-fn 'puget)
    (setq cider-repl-use-pretty-printing t)
    (setq cider-clojure-cli-aliases ":dev:cider"))

  (use-package rainbow-delimiters
    :ensure nil
    :hook ((clojure-mode . rainbow-delimiters-mode)
           (cider-repl-mode . rainbow-delimiters-mode)))

  ;; In your Clojure configuration section, add these key bindings:
  (with-eval-after-load 'clojure-mode
    (define-key clojure-mode-map [f3] 'cider-find-var)  ; equivalent to lsp-find-definition
    (define-key clojure-mode-map [f4] 'cider-xref-fn-refs-select) ; equivalent to lsp-find-references
    (define-key clojure-mode-map (kbd "M-.") 'cider-find-var)
    (define-key clojure-mode-map (kbd "M-,") 'cider-pop-back))

  ;; Also add Evil bindings if needed
  (with-eval-after-load 'evil
    (evil-define-key '(normal visual) clojure-mode-map
      (kbd "M-.") 'cider-find-var
      (kbd "M-,") 'cider-pop-back))

#+end_src

* Cider REPL Configuration

#+begin_src emacs-lisp

  ;; Debugging Setup
  (setq cider-cljs-lein-repl
        "(do (require 'figwheel-sidecar.repl-api)
           (figwheel-sidecar.repl-api/start-figwheel!)
           (figwheel-sidecar.repl-api/cljs-repl))")

  (setq cider-debug-display-locals t)
  (setq cider-debug-prompt 'overlay)

  ;; Optional but Recommended Packages
  (use-package clj-refactor
    :ensure nil
    :config
    (cljr-add-keybindings-with-prefix "C-c C-m")
    :hook (clojure-mode . clj-refactor-mode))

  (use-package flycheck-clj-kondo
    :ensure nil)

  (use-package aggressive-indent
    :ensure nil
    :hook (clojure-mode . aggressive-indent-mode))

  ;; Testing Setup  
  (setq cider-test-show-report-on-success t)
  (setq cider-auto-select-test-report-buffer t)


  ;; REPL Configuration
  (setq cider-repl-history-file ".cider-repl-history")
  (setq cider-repl-wrap-history t)
  (setq cider-repl-history-size 3000)
#+end_src

* treemacs configuration
#+begin_src emacs-lisp

(defun my/treemacs-peek ()
  "Peek at file content in a temporary window without creating a permanent buffer."
  (interactive)
  (when-let* ((window (selected-window))
              (btn (treemacs-current-button))
              (file (treemacs-button-get btn :path)))
    (when (file-exists-p file)
      (if-let ((peek-window (next-window)))
          (with-selected-window peek-window
            (find-file file)
            (read-only-mode -1))  ; Make buffer writable
        (split-window-right)
        (other-window 1)
        (find-file file)
        (read-only-mode -1))  ; Make buffer writable
      (message "Peek mode: press q to close"))))

(defun my/treemacs-close-peek ()
  "Close the peek window if it exists."
  (interactive)
  (when (and (eq major-mode 'treemacs-mode)
             (> (count-windows) 1))
    (delete-window (next-window))))

(use-package treemacs
  :ensure nil
  :config
  (setq treemacs-indentation 1
  	treemacs-indentation-string "  "
  	treemacs-width 35
  	treemacs-show-hidden-files t
  	treemacs-show-git-status t
  	treemacs-no-png-images nil
  	treemacs-collapse-dirs 3
  	treemacs-follow-mode t
  	treemacs-project-follow-mode t)

  (treemacs-load-theme "all-the-icons")

  :bind
  (:map global-map
	("C-c t t" . treemacs)
	("C-c t f" . treemacs-select-window)))

(add-hook 'treemacs-mode-hook
      	    (lambda() (display-line-numbers-mode -1)))

(with-eval-after-load 'treemacs
  (define-key treemacs-mode-map (kbd "P") #'my/treemacs-peek)
  (define-key treemacs-mode-map (kbd "q") #'my/treemacs-close-peek))

#+end_src

* debugging with dap-mode?

Starting to believe i will never use DAP

#+begin_src emacs-lisp

  ;; will implement later.
  
#+end_src

* Some packages that make it easy to work with JSON-MEM

#+begin_src emacs-lisp

;; JSON navigation with TAB behavior similar to org-mode
(defun my/json-next-element ()
  "Move to next element in a JSON array, handling nested structures."
  (interactive)
  (let ((depth 0)
	(in-string nil))
    ;; Keep moving forward until we find a comma at our nesting level
    (while (and (< (point) (point-max))  ; don't go past end of buffer
		(or (/= depth 0)          ; keep going if we're in nested structure
                    (not (looking-at-p ","))))  ; or haven't found a comma
      ;; Track if we're in a string
      (when (and (looking-at-p "\"")
                 (not (save-excursion (backward-char) (looking-at-p "\\\\"))))
	(setq in-string (not in-string)))
      
      ;; Only count brackets when not in string
      (when (not in-string)
	(cond ((looking-at-p "[[{]")
               (setq depth (1+ depth)))
              ((looking-at-p "[]}]")
               (setq depth (1- depth)))))
      
      (forward-char))
    
    ;; If we found a comma, move past it and any whitespace
    (when (looking-at-p ",")
      (forward-char)
      (skip-chars-forward "[:space:]\n")))) 

(defun my/json-previous-element ()
  "Move to previous element in a JSON array, handling nested structures."
  (interactive)
  (let ((depth 0)
	(in-string nil))
    ;; Keep moving backward until we find a comma at our nesting level
    (while (and (> (point) (point-min))  ; don't go past start of buffer
		(or (/= depth 0)          ; keep going if we're in nested structure
                    (not (looking-back "," 1))))  ; or haven't found a comma
      (backward-char)
      
      ;; Track if we're in a string
      (when (and (looking-at-p "\"")
		 (not (save-excursion (backward-char) (looking-at-p "\\\\"))))
	(setq in-string (not in-string)))
      
      ;; Only count brackets when not in string
      (when (not in-string)
	(cond ((looking-at-p "[]}]")
               (setq depth (1+ depth)))
              ((looking-at-p "[[{]")
               (setq depth (1- depth))))))
    
    ;; If we found a comma, skip backward over whitespace
    (when (looking-back "," 1)
      (backward-char)
      (skip-chars-backward "[:space:]\n"))))

(use-package json-mode
  :ensure nil
  :config)

(with-eval-after-load 'json-mode
  (with-eval-after-load 'evil
    ;; Use a local hook to set up JSON-specific key handling
    (defun my/setup-json-mode-keys ()
      ;; Locally unbind the keys
      (when (boundp 'evil-normal-state-local-map)
        (define-key evil-normal-state-local-map (kbd "C-n") nil)
        (define-key evil-normal-state-local-map (kbd "C-p") nil))
      
      ;; Add our JSON-specific bindings
      (evil-local-set-key 'normal (kbd "C-n") 'my/json-next-element)
      (evil-local-set-key 'normal (kbd "C-p") 'my/json-previous-element))
    
    ;; Add the hook
    (add-hook 'json-mode-hook 'my/setup-json-mode-keys)))

(use-package yafolding
  :ensure nil)

(use-package yasnippet-capf
  :ensure nil
  :after cape
  :init
  (defun my/yasnippet-capf-h ()
    (add-to-list 'completion-at-point-functions #'yasnippet-capf))
  :hook
  (emacs-lisp-mode . my/yasnippet-capf-h))

#+end_src

* YASnippet Configuration

#+begin_src emacs-lisp
  ;; Basic YASnippet setup
  (use-package yasnippet
    :ensure nil
    :hook ((prog-mode . yas-minor-mode)
           (org-mode . yas-minor-mode)
           (text-mode . yas-minor-mode)
           (cider-repl-mode . yas-minor-mode)        ;; Enable in Clojure REPL
           (inferior-python-mode . yas-minor-mode))  ;; Enable in Python REPL
    :config
    (yas-reload-all)
    (setq yas-snippet-dirs
          '("~/.emacs.d/snippets"  ;; personal snippets
            yasnippet-snippets-dir ;; collection from yasnippet-snippets package
            ))
    :bind
    (:map yas-minor-mode-map
          ("C-c y n" . yas-new-snippet)
          ("C-c y v" . yas-visit-snippet-file)
          ("C-c y i" . yas-insert-snippet)))

  ;; Install the main snippet collection
  (use-package yasnippet-snippets
    :ensure nil
    :after yasnippet)

  ;; Optional: Add Clojure snippets if you work with Clojure
  (use-package clojure-snippets
    :ensure nil
    :after (yasnippet clojure-mode))


  ;; Integrate with Corfu completion
  (with-eval-after-load 'corfu
    (add-to-list 'completion-at-point-functions #'yasnippet-capf))

  ;; Add Consult integration for better snippet selection
  (use-package consult-yasnippet
    :ensure nil
    :bind ("C-c y" . consult-yasnippet))

  (use-package yafolding
    :ensure nil
    :hook ((json-mode . yafolding-mode)
           (python-ts-mode . yafolding-mode)
           (clojure-mode . yafolding-mode))
    :config
    ;; Global yafolding bindings
    (with-eval-after-load 'yafolding
      (define-key yafolding-mode-map (kbd "C-c C-a") 'yafolding-toggle-all)
      (define-key yafolding-mode-map (kbd "C-c C-s") 'yafolding-show-all)
      (define-key yafolding-mode-map (kbd "C-c C-h") 'yafolding-hide-all)
      (define-key yafolding-mode-map (kbd "C-c [") 'yafolding-hide-region)
      (define-key yafolding-mode-map (kbd "C-c ]") 'yafolding-show-region)

      (evil-define-key 'normal yafolding-mode-map
        (kbd "TAB") 'yafolding-toggle-element))
    
    ;; JSON-specific evil bindings with higher precedence
    (with-eval-after-load 'json-mode
      ;; Remove TAB from global map in json-mode
      (define-key json-mode-map (kbd "TAB") nil)
      ;; Define evil normal state binding
      (evil-define-key 'normal json-mode-map
        [tab] 'yafolding-toggle-element
        (kbd "TAB") 'yafolding-toggle-element)))  

#+end_src

* REST support

#+begin_src emacs-lisp

  (use-package restclient
    :ensure nil
    :mode ("\\.http\\'" . restclient-mode))
  
#+end_src

* TODO Uvicron compilation mappings for FastAPI projects

This is just an easy for me to start up my various python projects.  I realize that this is not generic and is better off outside of dotfiles.  It makes no sense for people who are not involved in these projects

#+begin_src emacs-lisp
  ;; Create a keymap for uvicorn commands
  (defvar uvicorn-command-map
    (let ((map (make-sparse-keymap)))
      (define-key map (kbd "1") 
                  (lambda () 
                    (interactive)
                    (let ((default-directory (project-root (project-current t)))
                          (compilation-buffer-name-function
                           (lambda (_mode) "*uvicorn-iOCR*")))
                      (compile "PYTHONPATH=$PYTHONPATH:. uvicorn app.iOCR_app:app --reload --port 8123 --host 0.0.0.0"))))
      
      (define-key map (kbd "2")
                  (lambda ()
                    (interactive)
                    (let ((default-directory (project-root (project-current t)))
                          (compilation-buffer-name-function
                           (lambda (_mode) "*uvicorn-CVC*")))
                      (compile "PYTHONPATH=$PYTHONPATH:. uvicorn app.CVC_app:app --reload --port 8124 --host 0.0.0.0"))))

      (define-key map (kbd "3")
                  (lambda ()
                    (interactive)
                    (let ((default-directory (project-root (project-current t)))
                          (compilation-buffer-name-function
                           (lambda (_mode) "*uvicorn-Blens*")))
                      (compile "PYTHONPATH=$PYTHONPATH:. uvicorn app.billuminati-app:app --reload --port 8125 --host 0.0.0.0"))))
      map))

  ;; Create the prefix key binding
  (global-set-key (kbd "C-c u") uvicorn-command-map)

  ;; Add which-key descriptions
  (with-eval-after-load 'which-key
    (which-key-add-key-based-replacements
      "C-c u" "uvicorn"
      "C-c u 1" "start iOCR"
      "C-c u 2" "start CVC"
      "C-c u 3" "start Billi"))  
#+end_src

* Evil - Elisp keymap customization
This doesnt seem to be working as expected.  messing up the code.  Can move this to the paredit area.  I think paredit already has C-M-u/d/n/p which kind of get this done and these bindings are somewhat difficult to remember unless you have already used it a lot in vim and have developed muscle memory
Needs to be placed along with all the other with-eval-after-load 'evil customizations so that they are all in one place

#+begin_src emacs-lisp

(with-eval-after-load 'evil
  (evil-define-key '(normal visual) emacs-lisp-mode-map
    (kbd "]e") 'evil-cp-end-of-defun    ; Jump to end of top-level form
    (kbd "[e") 'evil-cp-beginning-of-defun  ; Jump to start of top-level form
    (kbd "M-j") 'evil-cp-next-sexp      ; Jump to next sexp
    (kbd "M-k") 'evil-cp-previous-sexp)) ; Jump to previous sexp

#+end_src

* Evil - Buffer customization
This overrides evil behaviour of using Esc to close special buffers.  This sometimes causes more harm than good.  this becomes necessary because in buffers like python compilation and repl and eshell, if Vi is active, then you are forced to hit esc to use other commands that allow you do search in the buffer etc.  The solution is to learn to some some emacs native navigation commands to move around in such buffers otherwise, hitting Esc closes the buffers and for someone using Vi, hitting Esc is second nature 

#+begin_src emacs-lisp

  ;; Prevent ESC from closing windows in special buffers
  (with-eval-after-load 'evil
    (evil-define-key 'normal special-mode-map [escape] 'evil-normal-state)
    (evil-define-key 'normal compilation-mode-map [escape] 'evil-normal-state)
    (evil-define-key 'normal cider-repl-mode-map [escape] 'evil-normal-state))

  ;; Alternative approach if the above doesn't work for all cases
  (defun my/prevent-escape-window-close ()
    "Prevent escape from closing windows in special buffers."
    (local-set-key [escape] 'evil-normal-state))

  (add-hook 'compilation-mode-hook #'my/prevent-escape-window-close)
  (add-hook 'special-mode-hook #'my/prevent-escape-window-close)
  (add-hook 'cider-repl-mode-hook #'my/prevent-escape-window-close)

#+end_src

* MANAGED BY EMACS
** TODO Have no clue if this is actually being used at all

#+begin_src emacs-lisp

(custom-set-variables
 ;; custom-set-variables was added by Custom.
 ;; If you edit it by hand, you could mess it up, so be careful.
 ;; Your init file should contain only one such instance.
 ;; If there is more than one, they won't work right.
 '(safe-local-variable-values
   '((eval add-hook 'cider-connected-hook
	   (lambda nil
	     (shell-command "npx shadow-cljs server")
	     (sleep-for 5)
	     (shell-command "npm run watch:css &"))
	   nil 'local)
     (auto-save-default)
     (make-backup-files)
     (eval pyvenv-activate
	   (expand-file-name ".venv"
			     (project-root
			      (project-current)))))))

#+end_src

* Tramp specific setup

#+begin_src emacs-lisp
;; Prevent TRAMP from hanging with Vertico
(setq remote-file-name-inhibit-cache nil)
;; (setq tramp-shell-prompt-pattern "\\(?:^\\|\r\\)[^]#$%>\n]*#?[]#$%>].* *\\(^[\\[[0-9;]*[a-zA-Z] *\\)*")
(setq tramp-verbose 1)

;; Improve TRAMP performance with Vertico/Marginalia
(setq tramp-completion-reread-directory-timeout nil)

;; Disable Corfu on remote files
(add-hook 'corfu-mode-hook
          (lambda ()
            (when (file-remote-p default-directory)
              (corfu-mode -1))))

;; Adjust Project.el for better TRAMP handling
(setq project-switch-commands 'project-find-file)

;; Optional: Disable Cape file completion on remote files
(setq cape-file-directory-must-exist nil)
#+end_src

* EWW configuration

** TODO Probably something that i will get rid of later on.  I dont see myself using this at all

#+begin_src emacs-lisp 

;; EWW configuration
(require 'eww)
(setq browse-url-browser-function 'eww-browse-url) ;; Use EWW as default browser
(setq eww-search-prefix "https://duckduckgo.com/html?q=") ;; Set search engine

;; Nicer rendering
(setq shr-use-colors nil) ;; No colors
(setq shr-use-fonts t)    ;; Use fonts
(setq shr-max-width 80)   ;; Wrap at 80 chars
(setq shr-discard-aria-hidden t)

;; Key bindings for EWW
(global-set-key (kbd "C-c w") 'eww)
(global-set-key (kbd "C-c o") 'browse-url-external) ;; Open in external browser when needed

#+end_src

* Nix mode
** TODO There is also a =nix-ts-mode=.  wonder if that is complementary to this.  Need to figure it out

#+begin_src emacs-lisp

(use-package transient
  :ensure nil)

(use-package nix-mode
  :ensure nil)

#+end_src

* mu4e-dashboard

#+begin_src emacs-lisp 

;; Load mu4e-dashboard
(use-package mu4e-dashboard
  :after mu4e
  :config
  ;; Set the dashboard file
  (setq mu4e-dashboard-file "~/.config/emacs/mu4e-dashboard.org")
  
  ;; If you want a default dashboard, you might need to create one
  ;; or copy the example from the repository
  
  ;; Optional: bind a key to open the dashboard
  :bind (:map mu4e-main-mode-map
              ("d" . mu4e-dashboard)))

#+end_src

* Editor customization for programming modes
** move-text

#+begin_src emacs-lisp

(use-package move-text
  :ensure nil
  :bind
  (("C-M-<up>" . move-text-up)
   ("C-M-<down>" . move-text-down)))
#+end_src

** Paredit

#+begin_src emacs-lisp

(use-package paredit
  :ensure nil
  :hook ((emacs-lisp-mode
          clojure-mode
          clojurescript-mode
          cider-repl-mode) . paredit-mode)
  :config
  ;; Bind paredit commands in insert state for elisp
  (evil-define-key 'insert emacs-lisp-mode-map
    (kbd "C-<left>") 'paredit-backward-slurp-sexp
    (kbd "C-<right>") 'paredit-forward-slurp-sexp
    (kbd "C-M-<left>") 'paredit-backward-barf-sexp
    (kbd "C-M-<right>") 'paredit-forward-barf-sexp)
  
  ;; Same bindings for clojure modes
  (evil-define-key 'insert clojure-mode-map
    (kbd "C-<left>") 'paredit-backward-slurp-sexp
    (kbd "C-<right>") 'paredit-forward-slurp-sexp
    (kbd "C-M-<left>") 'paredit-backward-barf-sexp
    (kbd "C-M-<right>") 'paredit-forward-barf-sexp)
  
  ;; Also for ClojureScript
  (evil-define-key 'insert clojurescript-mode-map
    (kbd "C-<left>") 'paredit-backward-slurp-sexp
    (kbd "C-<right>") 'paredit-forward-slurp-sexp
    (kbd "C-M-<left>") 'paredit-backward-barf-sexp
    (kbd "C-M-<right>") 'paredit-forward-barf-sexp)
  
  ;; And CIDER REPL
  (evil-define-key 'insert cider-repl-mode-map
    (kbd "C-<left>") 'paredit-backward-slurp-sexp
    (kbd "C-<right>") 'paredit-forward-slurp-sexp
    (kbd "C-M-<left>") 'paredit-backward-barf-sexp
    (kbd "C-M-<right>") 'paredit-forward-barf-sexp))
#+end_src

** TODO COMMENT Smartparens
Need to figure out what this does that is different from paredit.  infact i see the same bindings here that i see in paredit-mode

#+begin_src emacs-lisp 
;; (use-package smartparens
;;   :ensure nil 
;;   :config
;;   ;; Load the default configuration
;;   (require 'smartparens-config)
  
;;   ;; Enable smartparens in Python mode
;;   (add-hook 'python-mode-hook #'smartparens-mode)
  
;;   ;; Optional: Use strict mode for even better structural editing
;;   ;; (add-hook 'python-mode-hook #'smartparens-strict-mode)
  
;;   ;; Python-specific pairs
;;   (sp-local-pair 'python-mode "'" "'" :unless '(sp-in-comment-p sp-in-string-p))
;;   (sp-local-pair 'python-mode "\"" "\"" :unless '(sp-in-comment-p sp-in-string-p))
;;   (sp-local-pair 'python-mode "'''" "'''")
;;   (sp-local-pair 'python-mode "\"\"\"" "\"\"\"")
  
;;   ;; Useful keybindings for Python
;;   :bind (:map smartparens-mode-map
;;               ("C-M-f" . sp-forward-sexp)
;;               ("C-M-b" . sp-backward-sexp)
;;               ("C-<left>" . sp-backward-slurp-sexp)
;;               ("C-<right>" . sp-forward-slurp-sexp)
;;               ("C-M-<left>" . sp-backward-barf-sexp)
;; 	      ("C-M-<right>" . sp-forward-barf-sexp)
;;               ))

#+end_src

* mu4e  - Basic Configuration
#+begin_src emacs-lisp

(use-package mu4e
  :ensure nil  ;; Provided by Nix, no need to install via package.el
  :load-path "/nix/store/97ymyq978919zfqva4p15r4ddzzkkz0l-emacs-mu4e-1.12.7/share/emacs/site-lisp/elpa/mu4e-1.12.7"
  :config
  ;; Account settings
  (setq user-full-name "Ajaneesh Rajashekharaiah"
        user-mail-address "ajaneesh.rajashekharaiah@ihx.in"
        mu4e-maildir "~/Mail"
        mu4e-attachment-dir "~/Downloads")
  
  ;; Sending mail configuration
  (setq message-send-mail-function 'message-send-mail-with-sendmail
        send-mail-function 'message-send-mail-with-sendmail
        sendmail-program "/etc/profiles/per-user/nixos/bin/msmtp"
        message-sendmail-f-is-evil t
        message-sendmail-extra-arguments '("--read-envelope-from"))
  
  ;; Folder structure
  (setq mu4e-sent-folder "/[Gmail].Sent Mail"
        mu4e-drafts-folder "/[Gmail].Drafts"
        mu4e-trash-folder "/[Gmail].Bin"
        mu4e-refile-folder "/[Gmail].All Mail")
  
  ;; Shortcuts and mailbox sync
  (setq mu4e-maildir-shortcuts '(("/INBOX" . ?i) 
                                 ("/[Gmail].Sent Mail" . ?s))
        mu4e-get-mail-command "mbsync -a"
        mu4e-update-interval 300)
  
  ;; Signature
  (setq mu4e-compose-signature "-Ajaneesh"
        mu4e-compose-signature-auto-include t)
  
  ;; ┌────────────────────────────────────────────────────────────────┐
  ;; │                     Header View Configuration                   │
  ;; └────────────────────────────────────────────────────────────────┘
  
  ;; Headers appearance and behavior
  (setq mu4e-headers-fields '((:date . 12) 
                              (:flags . 6) 
                              (:from . 25) 
                              (:subject))
        mu4e-headers-date-format "%Y-%m-%d %H:%M"
        mu4e-headers-long-date-format "%Y-%m-%d %H:%M"
        mu4e-headers-time-format "%H:%M"
        mu4e-headers-visible-lines 15
        mu4e-headers-sort-direction 'descending
        mu4e-headers-search-skip-duplicates t
        mu4e-headers-skip-duplicates t
        mu4e-headers-include-related nil)
  
  ;; Use fancy characters in headers
  (setq mu4e-use-fancy-chars t
        mu4e-headers-draft-mark     '("D" . "🖊️")  ;; Draft
        mu4e-headers-flagged-mark   '("F" . "⚑")   ;; Flagged
        mu4e-headers-new-mark       '("N" . "✱")   ;; New
        mu4e-headers-passed-mark    '("P" . "➥")   ;; Passed/Forwarded
        mu4e-headers-replied-mark   '("R" . "↵")   ;; Replied
        mu4e-headers-seen-mark      '("S" . "✓")   ;; Seen
        mu4e-headers-trashed-mark   '("T" . "♻")   ;; Trashed
        mu4e-headers-attach-mark    '("a" . "📎")  ;; Attachment
        mu4e-headers-encrypted-mark '("x" . "🔒")  ;; Encrypted
        mu4e-headers-signed-mark    '("s" . "🔑")  ;; Signed
        mu4e-headers-unread-mark    '("u" . "●"))  ;; Unread

  ;; ┌────────────────────────────────────────────────────────────────┐
  ;; │                     Message View Configuration                  │
  ;; └────────────────────────────────────────────────────────────────┘
  
  ;; Message view settings
  (setq mu4e-view-fields '(:from :to :cc :subject :flags :date 
				 :maildir :mailing-list :tags 
				 :attachments :signature)
        mu4e-view-header-field-format "%s: %s\n"
        mu4e-view-header-separator (propertize "\n" 'face '(:background "gray90" :height 0.5))
        mu4e-view-show-addresses t
        mu4e-view-auto-mark-as-read t
        mu4e-split-view 'vertical
        mu4e-split-view-width 10
        mu4e-use-color t)
  
  ;; HTML rendering preferences
  (setq mu4e-view-prefer-html t
        mu4e-view-html-plaintext-ratio-heuristic most-positive-fixnum
        mu4e-view-show-images t
        mu4e-view-image-max-width 800)
  
  ;; Use xwidget webkit for HTML viewing if available
  (when (fboundp 'xwidget-webkit-browse-url)
    (setq mu4e-view-use-xwidget t))
  
  ;; ┌────────────────────────────────────────────────────────────────┐
  ;; │                   Message View Mode Hooks                       │
  ;; └────────────────────────────────────────────────────────────────┘
  
  ;; Set up improved appearance for message viewing
  (defun my/mu4e-view-mode-setup ()
    "Enhanced setup for mu4e-view-mode with better formatting and readability."
    ;; Use variable-pitch fonts for better readability
    (variable-pitch-mode 1)
    (setq line-spacing 0.1)
    (setq buffer-face-mode-face '(:family "Source Sans Pro" :height 110))
    (buffer-face-mode)
    
    ;; Activate olivetti mode for centered text
    (when (fboundp 'olivetti-mode)
      (olivetti-mode 1)
      (setq olivetti-body-width 90))
    
    ;; Ensure images are displayed
    (when (fboundp 'shr-toggle-images)
      (shr-toggle-images 1)))
  
  (add-hook 'mu4e-view-mode-hook 'my/mu4e-view-mode-setup)
  
  ;; HTML rendering settings
  (setq shr-color-visible-luminance-min 70
        shr-use-colors t
        shr-use-fonts t
        shr-max-width 90
        shr-discard-aria-hidden t))
#+end_src

* mu4e - Appearance and UI Enhancements

#+begin_src emacs-lisp

;; Header appearance with Modus themes
(with-eval-after-load 'modus-themes
  (setq modus-themes-mail-citations 'intense)  ;; Make citations more distinct
  (setq modus-themes-completions '((matches . (extrabold))
                                   (selection . (semibold accented))
                                   (popup . (accented intense))))
  
  ;; If using modus-vivendi (dark theme)
  (when (eq (modus-themes--current-theme) 'modus-vivendi)
    (set-face-attribute 'mu4e-header-highlight-face nil
                        :background (modus-themes-get-color-value 'bg-hl-alt)
                        :underline nil)))

;; Improve header appearance
(with-eval-after-load 'mu4e
  (set-face-attribute 'mu4e-header-face nil :family "Source Sans Pro" :height 90)
  (set-face-attribute 'mu4e-header-title-face nil :family "Source Sans Pro" :height 90)
  (set-face-attribute 'mu4e-header-key-face nil :family "Source Sans Pro" :height 90)
  (set-face-attribute 'mu4e-header-value-face nil :family "Source Sans Pro" :height 90)
  (set-face-attribute 'mu4e-contact-face nil :family "Source Sans Pro" :height 90))

(defun my/force-mu4e-use-xwidget ()
  "Force mu4e to use xwidget for HTML rendering."
  (when (fboundp 'xwidget-webkit-browse-url)
    (message "xwidget-webkit is available")
    (setq mu4e-view-prefer-html t)
    (setq mu4e-view-html-plaintext-ratio-heuristic most-positive-fixnum)
    (setq mu4e-view-use-xwidget t)
    (message "mu4e configured to use xwidget for HTML")))

(with-eval-after-load 'mu4e
  (my/force-mu4e-use-xwidget))

#+end_src

* mu4e - Notification and Alerts

#+begin_src emacs-lisp


;; Email notifications
(use-package mu4e-alert
  :ensure nil
  :after mu4e
  :config
  (mu4e-alert-set-default-style 'libnotify)
  (add-hook 'after-init-hook #'mu4e-alert-enable-notifications)
  (add-hook 'after-init-hook #'mu4e-alert-enable-mode-line-display))

#+end_src

* mu4e - org-mime integration for composition
** Hooks that could potentially interfere with org-message

#+begin_src emacs-lisp

;; ;; Automatically convert org buffer to HTML email when sending
;; (add-hook 'message-send-hook
;;           (lambda ()
;;             (when (and (eq major-mode 'org-mode)
;;                        (derived-mode-p 'message-mode)
;;                        (not (message-mail-p)))
;;               (org-mime-htmlize))))

;; ;;  Add keybinding to compose HTML email with Org
;; (with-eval-after-load 'mu4e
;;   (define-key mu4e-compose-mode-map (kbd "C-c M-h") 'org-mime-edit-mail-in-org-mode))

;; (add-hook 'message-send-hook 'org-mime-htmlize)
;; (add-hook 'message-send-hook 'org-mime-confirm-when-no-multipart)


#+end_src

** These should be safe to have even when org-msg is also configured and active

#+begin_src emacs-lisp

;; Org-mime for HTML email composition
(use-package org-mime
  :ensure nil
  :after (org mu4e)
  :config
  ;; Add a hook to convert org to HTML when sending
  (add-hook 'org-mime-html-hook
            (lambda ()
              (org-mime-change-element-style
               "pre" (format "color: %s; background-color: %s; padding: 0.5em;"
                             "#E6E1DC" "#232323"))))
  
  ;; Configure org-mime options
  (setq org-mime-export-options '(:section-numbers nil
						   :with-author nil
						   :with-toc nil
						   :with-latex nil))
  
  ;; Function to use HTML for HTML replies, text for text replies
  (setq org-mime-reply-function
        (lambda (msg)
          (if (string-match "text/html" (message-fetch-field "Content-Type"))
              (org-mime-htmlize)
            (message "Composing text-only reply"))))
  
  ;; Keybindings for converting between Org and HTML in emails
  (define-key message-mode-map (kbd "C-c M-o") 'org-mime-htmlize)
  (define-key org-mode-map (kbd "C-c M-o") 'org-mime-org-buffer-htmlize))


(setq org-latex-create-formula-image-program 'dvipng)
(setq org-preview-latex-default-process 'dvipng)
#+end_src

* mu4e - org-msg integration

#+begin_src emacs-lisp 

(use-package org-msg
  :ensure nil
  :init  ;; Use :init instead of :config to ensure it loads before mu4e uses it
  (setq org-msg-options "html-postamble:nil H:5 num:nil ^:{} toc:nil author:nil email:nil \\n:t"
        org-msg-startup "hidestars indent inlineimages"
        org-msg-default-alternatives '((new . (text html))
                                       (reply-to-html . (text html))
                                       (reply-to-text . (text html)))  ;; Always include HTML
        org-msg-convert-citation t
        org-msg-signature "

Regards,
Ajaneesh")
  (org-msg-mode 1))

(with-eval-after-load 'mu4e
  ;; Tell mu4e to use org-msg for composition
  (setq mu4e-compose-format-flowed t)

  (require 'org-msg)
  (org-msg-mode 1) 
  
  ;; Make sure org-msg uses your HTML viewing preferences
  (when (fboundp 'xwidget-webkit-browse-url)
    (setq mu4e-view-use-xwidget t)
    (setq org-msg-enforce-css
          (concat "blockquote {border-left: 4px solid #ccc; padding-left: 10px;}\n"
                  "code {background-color: #f9f9f9; padding: 2px 4px; border-radius: 3px;}\n"
                  "pre {background-color: #f9f9f9; padding: 8px; border-radius: 3px; overflow: auto;}")))
                  
  ;; Optional: Customize the CSS for HTML emails
  (setq org-msg-enforce-css
      "pre {font-family: monospace; font-size: 90%; overflow: auto; margin: 0.8em; padding: 0.5em; background-color: #f5f5f5;}
       .src {background-color: #f5f5f5; padding: 8px;}
       blockquote {border-left: 4px solid #ddd; padding: 0 15px; color: #777;}
       .quote {color: #777;}
       .timestamp {color: #999;}
       h1,h2,h3,h4,h5,h6 {font-family: Arial, sans-serif; color: #333;}
       li {margin: 0.5em 0;}
       a {color: #0066cc; text-decoration: none;}
       a:hover {text-decoration: underline;}
       p {margin: 0.5em 0;}"))
(setq org-msg-enforce-css
      (concat org-msg-enforce-css
              "pre.src {background-color: #282c34; color: #bbc2cf; padding: 0.5em;}")
      org-msg-startup "hidestars indent inlineimages")

(add-hook 'mu4e-compose-mode-hook 'org-msg-mode)
(add-hook 'mu4e-compose-pre-hook 'org-msg-mode)

(setq org-msg-default-alternatives '((new . (text html))
                                     (reply-to-html . (text html))
                                     (reply-to-text . (text html))))

(setq org-msg-options "html-postamble:nil H:5 num:nil ^:{} toc:nil author:nil email:nil \\n:t tex:t")

;; For multiple templates related to email
(setq org-capture-templates
      '(("e" "Email" entry (file+headline "~/org/mail.org" "Emails")
         "* TODO %:subject\nSCHEDULED: %t\n%a\n%i\n%?")
        ("r" "Email Reply" entry (file+headline "~/org/mail.org" "Replies")
         "* TODO Reply to %:fromname on %:subject\nSCHEDULED: %t\n%a\n%i\n%?")
        ("f" "Email Follow-up" entry (file+headline "~/org/mail.org" "Follow-ups")
         "* TODO Follow up with %:fromname\nSCHEDULED: %<+3d>\n%a\n%i\n%?")))

;; Capture message links
(defun my/capture-mail-follow (msg)
  (when (eq major-mode 'mu4e-view-mode)
    (mu4e-view-message-action 'capture)))

(add-hook 'org-capture-mode-hook 'my/capture-mail-follow)

(remove-hook 'mu4e-compose-mode-hook 'org-msg-mode)  ;; Remove potentially duplicate hook
(add-hook 'mu4e-compose-pre-hook
          (lambda ()
            (org-msg-mode 1)
            (message "org-msg activated for composition")))
#+end_src

** mu4e - toggle between mime and msg packages for org/html support

#+begin_src emacs-lisp 

;; (defun my/toggle-org-msg-mode ()
;;   "Toggle between org-msg and standard composition."
;;   (interactive)
;;   (if org-msg-mode
;;       (progn
;;         (org-msg-mode -1)
;;         (message "Standard email composition enabled"))
;;     (org-msg-mode 1)
;;     (message "Org-msg HTML composition enabled")))

;; (with-eval-after-load 'mu4e
;;   (define-key mu4e-headers-mode-map (kbd "C-c m") 'my/toggle-org-msg-mode)
;;   (define-key mu4e-view-mode-map (kbd "C-c m") 'my/toggle-org-msg-mode))

#+end_src

* mu4e - Enhacement Packages

#+begin_src emacs-lisp

;; Use emojis in emails
(use-package emojify
  :ensure t
  :hook (mu4e-view-mode . emojify-mode))

;; Centered reading with Olivetti
(use-package olivetti
  :ensure nil
  :config
  (setq olivetti-body-width 90)
  (setq olivetti-minimum-body-width 70)
  (setq olivetti-recall-visual-line-mode-entry-state t))

;; Icons in completion
(use-package all-the-icons
  :ensure nil)

(use-package all-the-icons-completion
  :ensure nil
  :after (marginalia all-the-icons)
  :hook (marginalia-mode . all-the-icons-completion-marginalia-setup))

#+end_src

* mu4e - Convenience Functions

#+begin_src emacs-lisp

;; Function to toggle between HTML and plain text view
(defun my/toggle-html-plain-text ()
  "Toggle between HTML and plain text view in mu4e."
  (interactive)
  (if (bound-and-true-p mu4e-view-prefer-html)
      (progn
        (setq mu4e-view-prefer-html nil)
        (message "Switched to plain text view"))
    (setq mu4e-view-prefer-html t)
    (message "Switched to HTML view"))
  (mu4e-view-refresh))

;; Add the toggle command to mu4e-view-mode-map
(with-eval-after-load 'mu4e-view
  (define-key mu4e-view-mode-map (kbd "C-c t") 'my/toggle-html-plain-text))
#+end_src

* mixed-pitch-mode configuration for org-mode

#+begin_src emacs-lisp

;; Configure mixed-pitch mode for Org
(use-package mixed-pitch
  :hook
  (org-mode . mixed-pitch-mode)
  :config
  (setq mixed-pitch-set-height t)
  ;; Keep code blocks, tables, etc in fixed-pitch
  (setq mixed-pitch-fixed-pitch-faces
        '(org-block
          org-block-begin-line
          org-block-end-line
          org-code
          org-document-info-keyword
          org-meta-line
          org-property-value
          org-special-keyword
          org-table
          org-verbatim
          line-number
          line-number-current-line)))

;; (with-eval-after-load 'all-the-icons
;;   (set-face-attribute 'treemacs-directory-face nil
;; 			:family "Source Sans Pro"
;; 			:height 0.9)
;;   (set-face-attribute 'treemacs-file-face nil
;; 			:inherit 'treemacs-directory-face))

;; (with-eval-after-load 'treemacs
;;   (treemacs-modify-theme "all-the-icons"
;;     :config
;;     (progn
;; 	(set-face-attribute 'treemacs-directory-face nil
;;   			    :family "Source Sans Pro"
;;   			    :height 0.9)
;; 	(set-face-attribute 'treemacs-file-face nil
;;   			    :inherit 'treemacs-directory-face))))

#+end_src

* Font and Color Configuration

#+begin_src emacs-lisp

;; Basic font definitions - KEEP THESE
(set-face-attribute 'default nil
                    :family "JetBrains Mono"
                    :height 90)

(set-face-attribute 'fixed-pitch nil 
                    :family "JetBrains Mono"
                    :height 90)

(set-face-attribute 'variable-pitch nil
                    :family "Source Sans Pro"
                    :height 120)

;; Ligature config - KEEP THIS
(use-package ligature
  :ensure nil
  :config
  (ligature-set-ligatures 't '("www" "**" "***" "**/" "*>" "*/" "\\\\" "\\\\\\"
                               "{-" "::" ":::" ":=" "!!" "!=" "!==" "-}" "--" "---" "-->"
                               "->>" "->" "-<" "-<<" "-~" "#{" "#[" "##" "###" "####"
                               "#(" "#?" "#_" "#_(" ".-" ".=" ".." "..<" "..." "?="))
  (global-ligature-mode t))

;; ==== NEW CENTRALIZED CONFIGURATION ====

(defun my/apply-fonts-and-faces ()
  "Apply centralized font and face settings, using Modus theme colors."
  (interactive)
  
  ;; Define our font families
  (let* ((fixed-font "JetBrains Mono")
         (variable-font "Source Sans Pro")
         (code-font-size 90)
         (ui-font-size 120)
         
         ;; Variable tuple for org headings
         (variable-tuple
          (cond ((x-list-fonts variable-font) `(:font ,variable-font))
                ((x-list-fonts "Lucida Grande") '(:font "Lucida Grande"))
                ((x-list-fonts "Verdana") '(:font "Verdana"))
                ((x-family-fonts "Sans Serif") '(:family "Sans Serif"))
                (nil (warn "Cannot find a Sans Serif Font."))))
         
         ;; Get base color from current theme
         (base-font-color (face-foreground 'default nil 'default))
         (headline `(:inherit default :foreground (modus-themes-get-color-value 'fg-main))))
    
    ;; ===== ORG MODE FACES =====
    (with-eval-after-load 'org
      (custom-theme-set-faces
       'user
       ;; Fixed-pitch elements
       `(org-block ((t (:inherit fixed-pitch))))
       `(org-code ((t (:inherit (shadow fixed-pitch)))))
       `(org-document-info-keyword ((t (:inherit (shadow fixed-pitch)))))
       `(org-indent ((t (:inherit (org-hide fixed-pitch)))))
       `(org-meta-line ((t (:inherit (font-lock-comment-face fixed-pitch)))))
       `(org-property-value ((t (:inherit fixed-pitch))))
       `(org-special-keyword ((t (:inherit (font-lock-comment-face fixed-pitch)))))
       `(org-table ((t (:inherit fixed-pitch :foreground ,(modus-themes-get-color-value 'blue-alt)))))
       `(org-tag ((t (:inherit (shadow fixed-pitch) :weight normal :height 0.8))))
       `(org-verbatim ((t (:inherit (shadow fixed-pitch)))))
       
       ;; Document structure with variable pitch
       `(org-document-title ((t (:inherit default ,@variable-tuple :height 2.0 :underline nil))))
       `(org-level-1 ((t (,@headline ,@variable-tuple))))
       `(org-level-2 ((t (,@headline ,@variable-tuple))))
       `(org-level-3 ((t (,@headline ,@variable-tuple))))
       `(org-level-4 ((t (,@headline ,@variable-tuple))))
       `(org-level-5 ((t (,@headline ,@variable-tuple))))
       `(org-level-6 ((t (,@headline ,@variable-tuple))))
       `(org-level-7 ((t (,@headline ,@variable-tuple))))
       `(org-level-8 ((t (,@headline ,@variable-tuple))))
       
       ;; Links and other elements
       `(org-link ((t (:foreground ,(modus-themes-get-color-value 'blue) :underline t)))))))

  ;; ===== TREEMACS FACES =====
  (with-eval-after-load 'treemacs
    ;; Make sure all files have at least a fallback icon
    (treemacs-define-custom-icon 
     (all-the-icons-faicon "file-o" :v-adjust 0.0 :height 0.8)
     "fallback")
    (custom-theme-set-faces
     'user
     `(treemacs-root-face ((t (:inherit variable-pitch :height 0.9))))
     `(treemacs-file-face ((t (:inherit variable-pitch :height 0.9))))
     `(treemacs-directory-face ((t (:inherit variable-pitch :height 0.9))))
     `(treemacs-git-modified-face ((t (:inherit variable-pitch :height 0.9))))
     `(treemacs-git-untracked-face ((t (:inherit variable-pitch :height 0.9))))))
  
  ;; ===== MU4E FACES =====
  (with-eval-after-load 'mu4e
    (custom-theme-set-faces
     'user
     `(mu4e-header-face ((t (:family ,variable-font :height 90))))
     `(mu4e-header-title-face ((t (:family ,variable-font :height 90))))
     `(mu4e-header-key-face ((t (:family ,variable-font :height 90))))
     `(mu4e-header-value-face ((t (:family ,variable-font :height 90))))
     `(mu4e-contact-face ((t (:family ,variable-font :height 90))))
     `(mu4e-highlight-face ((t (:background ,(modus-themes-get-color-value 'bg-active)
                                            :foreground ,(modus-themes-get-color-value 'fg-main)))))
     `(mu4e-header-highlight-face ((t (:background ,(modus-themes-get-color-value 'bg-hl-alt)
                                                   :underline nil))))))
  
  (message "Applied centralized font and face settings"))

;; Update your mu4e buffer-local theme to use Modus colors
(defun my/apply-mu4e-buffer-local-theme ()
  "Apply buffer-local light theme for mu4e using Modus Operandi colors."
  (when (derived-mode-p 'mu4e-view-mode 'mu4e-compose-mode)
    ;; Ensure we're working with buffer-local faces
    (buffer-face-mode 1)
    
    ;; Store the current theme
    (let ((current-theme (car custom-enabled-themes))
          (temp-theme nil))
      
      ;; Temporarily load modus-operandi if not already active
      (unless (eq current-theme 'modus-operandi)
        (load-theme 'modus-operandi t)
        (setq temp-theme 'modus-operandi))
      
      ;; Apply face remappings using Modus Operandi colors
      (face-remap-add-relative 'default 
                               :background (modus-themes-get-color-value 'bg-main)
                               :foreground (modus-themes-get-color-value 'fg-main))
      
      (face-remap-add-relative 'fringe 
                               :background (modus-themes-get-color-value 'bg-dim))
      
      (face-remap-add-relative 'mu4e-header-face 
                               :foreground (modus-themes-get-color-value 'fg-dim))
      
      (face-remap-add-relative 'mu4e-unread-face 
                               :foreground (modus-themes-get-color-value 'blue-warmer)
                               :weight 'bold)
      
      (face-remap-add-relative 'mu4e-highlight-face 
                               :background (modus-themes-get-color-value 'bg-active)
                               :foreground (modus-themes-get-color-value 'fg-main))
      
      (face-remap-add-relative 'mu4e-header-highlight-face 
                               :background (modus-themes-get-color-value 'bg-hl-alt))
      
      (face-remap-add-relative 'mode-line 
                               :background (modus-themes-get-color-value 'bg-mode-line-active)
                               :foreground (modus-themes-get-color-value 'fg-mode-line-active))
      
      (face-remap-add-relative 'mode-line-inactive 
                               :background (modus-themes-get-color-value 'bg-mode-line-inactive)
                               :foreground (modus-themes-get-color-value 'fg-mode-line-inactive))
      
      ;; Text rendering adjustments (only font family/size, no colors)
      (face-remap-add-relative 'variable-pitch :family "Source Sans Pro" :height 110)
      
      ;; Restore original theme if we temporarily changed it
      (when temp-theme
        (disable-theme temp-theme)
        (when current-theme
          (enable-theme current-theme))))))

;; Add hooks for mu4e buffer-local themes
;; (with-eval-after-load 'mu4e
;;   (add-hook 'mu4e-view-mode-hook 'my/apply-mu4e-buffer-local-theme)
;;   (add-hook 'mu4e-compose-mode-hook 'my/apply-mu4e-buffer-local-theme))

;; Modify your modus-themes configuration
(use-package modus-themes
  :ensure nil
  :config
  ;; Your existing settings...
  (setq modus-themes-mode-line '(accented borderless)
        modus-themes-bold-constructs t
        modus-themes-italic-constructs t
        modus-themes-fringes 'subtle
        modus-themes-tabs-accented t
        modus-themes-paren-match '(bold intense)
        modus-themes-prompts '(bold intense)
        modus-themes-completions '((matches . (extrabold underline))
  				   (selection . (semibold)))
        modus-themes-org-blocks 'tinted-background
        modus-themes-scale-headings t
        modus-themes-region '(bg-only)
        modus-themes-headings
        '((1 . (rainbow regular overline background 1.0))
          (2 . (rainbow regular background 1.0))
          (3 . (rainbow regular 1.0))
          (t . (semilight 1.0))))

  ;; Add our function to the theme loading hook
  (add-hook 'modus-themes-after-load-theme-hook #'my/apply-fonts-and-faces)
  
  ;; Load theme - this will trigger our hook
  (load-theme 'modus-vivendi t ))

;; Add a theme toggle function
(defun my/toggle-modus-theme ()
  "Toggle between light and dark Modus themes."
  (interactive)
  (if (eq (car custom-enabled-themes) 'modus-operandi)
      (load-theme 'modus-vivendi t) 
    (load-theme 'modus-operandi t)))

;; Key binding for toggling themes - currently conflicting with treemacs
;; (global-set-key (kbd "C-c t t") 'my/toggle-modus-theme)




#+end_src

* Global Configuration

#+begin_src emacs-lisp

;; ESC cancels all
(global-set-key (kbd "<escape>") 'keyboard-escape-quit)
(global-set-key [C-tab] 'other-window)

;; Prevent auto-centering
(setq scroll-conservatively 101)


(global-set-key [f5] 'revert-buffer)
(global-set-key (kbd "C-!") 'eval-expression)

#+end_src

** Focus on one window by toggling its full-screen view using F12

Hitting F12 hides other windows (except treemacs).  Any number of other windows may be open.  It will restore other buffers back when toggled.  But restoration only works till any actions are executed.  To be used only in context where you are peeking at something like a log file which is wrapping which would momentarily benefit from full screen view. 

#+begin_src emacs-lisp

  (defvar my/saved-window-config nil 
    "Store window configuration for maximize/restore.")

  (defun my/maximize-window ()
    "Maximize current window, keeping config for restore."
    (interactive)
    (if my/saved-window-config
        (progn
          (set-window-configuration my/saved-window-config)
          (setq my/saved-window-config nil)
          (message "Layout restored"))
      (setq my/saved-window-config (current-window-configuration))
      (delete-other-windows)
      (message "Window maximized - run command again to restore")))

  ;; Bind to a key of your choice later
  (global-set-key (kbd "<f12>") 'my/maximize-window)
  
#+end_src

** Use standard windows shortcut to close tabs for quickly killing buffers

Ctrl-K and RETURN would also do the same thing.  but i find this convenient and i use this as it matches with tab closing keymap in windows text editors. 

#+begin_src emacs-lisp

  (defun my/kill-current-buffer ()
    "Kill current buffer without confirmation."
    (interactive)
    (kill-buffer (current-buffer)))

  (global-set-key [C-f4] 'my/kill-current-buffer)

#+end_src

** Cycle through programming mode output buffers quickly using F6
This takes a list of regexp that identify buffers to cycle through.  useful for quickly getting to python compilation and clojure REPL buffers.  *I hardly ever use this as i end up opening way to many buffers of source files and it makes no sense to cycle through all of them* 

#+begin_src emacs-lisp
  (defun my/cycle-output-buffers ()
    "Cycle through compilation, cider and repl buffers."
    (interactive)
    (let* ((buffer-patterns '("\\*compilation\\*"
                              "\\*cider\\-repl.*\\*"
                              "\\*repl.*\\*"))
           ;; Get list of matching buffers
           (matching-buffers
            (seq-filter
             (lambda (buf)
               (let ((buf-name (buffer-name buf)))
                 (seq-some (lambda (pattern)
                             (string-match-p pattern buf-name))
                           buffer-patterns)))
             (buffer-list)))
           ;; Sort them by name for consistent cycling
           (sorted-buffers (sort matching-buffers
                                 (lambda (a b)
                                   (string< (buffer-name a)
                                            (buffer-name b)))))
           ;; Find current buffer's position
           (current-pos (seq-position sorted-buffers (current-buffer)))
           (num-buffers (length sorted-buffers)))
      
      (cond
       ((null sorted-buffers)
        (message "No matching buffers found"))
       ((null current-pos)
        ;; If current buffer isn't in the list, switch to first matching buffer
        (switch-to-buffer (car sorted-buffers)))
       (t
        ;; Switch to next buffer in cycle
        (switch-to-buffer
         (nth (mod (1+ current-pos) num-buffers)
              sorted-buffers))))))

  ;; Bind to F6
  (global-set-key [f6] 'my/cycle-output-buffers)
#+end_src

** Copy buffer message.
Useful stuff.  this is to avoid having to go to the Messages buffer to copy.  I use this mostly to query copilots for fixes as the last error that is flashed in mini buffer is usually the thing we use to research or debug
*This is not working anymore. It usually changes the buffer message as soon as C-c is hit.  It still copies text.  But some other useless nonsense*  The idea was to use this to copy file paths when navigating treemacs.  Treemacs usually shows the entire file path in the minibuffer
#+begin_src emacs-lisp

  (defvar my/last-minibuffer-message nil)

  (advice-add 'message :after 
              (lambda (&rest args)
                (when (car args)
                  (setq my/last-minibuffer-message (apply #'format-message args)))))

  (global-set-key (kbd "C-c w") (lambda () 
    				(interactive)
    				(when my/last-minibuffer-message
    				  (kill-new my/last-minibuffer-message)
    				  (let ((message-log-max nil)) ; prevent recursive message capture
    				    (message "Copied: %s" my/last-minibuffer-message)))))
#+end_src

** Custom editor file cycling for prog-mode
use F8 to cycle through open buffers matching the file extension of the current buffer. This is useful when you have some 4-5 py or clj files open and you want to find one of them by using a single key. probably not very useful in cases when too many such buffers are open unless we can get a completion popup.  that is the next step in the evolution of this customization
The grand plan is to get a popup completion so that a file can be picked,  that is still work in progress, even now it only toggles
between the open files which is ok when there aren't too many files open

#+begin_src emacs-lisp

(defun my/get-buffer-extension (&optional buffer)
  "Get the file extension of BUFFER or current buffer."
  (when-let* ((buffer (or buffer (current-buffer)))
              (file-name (buffer-file-name buffer)))
    (file-name-extension file-name)))

(defun my/cycle-same-extension-buffers (&optional reverse)
  "Cycle through buffers with same extension as current buffer."
  (interactive)
  (when (derived-mode-p 'prog-mode)
    (let* ((curr-ext (my/get-buffer-extension))
           (current-buf (current-buffer))
           ;; Get all matching buffers and sort them by name
           (same-ext-buffers
            (sort 
             (seq-filter
              (lambda (buf)
                (with-current-buffer buf
                  (and (buffer-file-name buf)
                       (derived-mode-p 'prog-mode)
                       (when-let ((ext (my/get-buffer-extension buf)))
                         (string= ext curr-ext)))))
              (buffer-list))
             (lambda (a b) 
               (string< (buffer-name a) (buffer-name b)))))
           ;; Find current position
           (current-index (cl-position current-buf same-ext-buffers))
           (total (length same-ext-buffers)))
      
      (when (and current-index (> total 1))
        ;; Calculate next position with wrapping
        (let* ((next-index (if reverse
                               (if (= current-index 0) 
                                   (1- total) 
                                 (1- current-index))
                             (if (= current-index (1- total)) 
                                 0 
                               (1+ current-index))))
               (next-buf (nth next-index same-ext-buffers)))
          
          ;; Switch buffer with messages suppressed
          (let ((inhibit-message t))
            (switch-to-buffer next-buf)
            ;; Show simple status message
            (message "[%d/%d] %s" 
                     (1+ next-index) 
                     total
                     (buffer-name next-buf))))))))

(defun my/cycle-same-extension-buffers-backward ()
  "Cycle through buffers with same extension as current buffer backwards."
  (interactive)
  (my/cycle-same-extension-buffers t))

;; Bind to F8 and Shift-F8
(define-key prog-mode-map [f8] 'my/cycle-same-extension-buffers)

#+end_src

** For one off updates in existing buffers
This is something that i use often.  it kind of makes it easier to deal with =lsp-find-references= and =lsp-find-definiton= when looking at code.  I can use a single key in most cases to navigate back and forth betwen caller and callee. Works especially well when there is a single caller, it simply toggles between the references.  When there is more than once reference, then it works a little like ripgrep.   

#+begin_src emacs-lisp

;; Define the smart reference finder
(defun my/smart-find-references ()
  "Enhanced reference finder that auto-jumps when there are exactly two references."
  (interactive)
  (let* ((orig-buf (current-buffer))
	 (orig-pos (point))
	 (refs (lsp-request "textDocument/references"
                            (lsp--make-reference-params nil nil)))
	 (num-refs (length refs)))
    (cond
     ;; No references found
     ((= num-refs 0)
      (message "No references found"))
     
     ;; Exactly two references - try to jump to the other one
     ((= num-refs 2)
      (let* ((current-uri (lsp--buffer-uri))
             (other-ref (car (seq-filter
                              (lambda (ref)
				(let ((ref-uri (lsp:location-uri ref)))
				  (or (not (string= ref-uri current-uri))
                                      (let* ((range (lsp:location-range ref))
                                             (start (lsp:range-start range))
                                             (line (lsp:position-line start))
                                             (character (lsp:position-character start))
                                             (cur-line (line-number-at-pos))
                                             (cur-char (current-column)))
					(or (/= (1+ line) cur-line)
                                            (/= character cur-char))))))
                              refs))))
	(if other-ref
            (lsp-goto-location other-ref)
          (message "Cannot determine other reference location"))))
     
     ;; More than two references - show all references
     (t (lsp-find-references)))))

(when (boundp 'python-ts-mode-map)
  (dolist (buffer (buffer-list))
    (with-current-buffer buffer
      (when (derived-mode-p 'python-ts-mode)
  	(define-key python-ts-mode-map [f4] 'my/smart-find-references)))))

#+end_src

* SQL Client configuration
#+begin_src emacs-lisp

;; Function to read from secrets.json
(defun my/read-postgres-secrets ()
  "Read PostgreSQL connection details from secrets.json"
  (let* ((json-object-type 'hash-table)
         (json-array-type 'list)
         (json-key-type 'string)
         (secrets-file (expand-file-name "~/.config/ihx/secrets.json"))
         (json-data (with-temp-buffer
                      (insert-file-contents secrets-file)
                      (json-read-from-string (buffer-string)))))
    (list :user (gethash "db_user" json-data)
          :database (gethash "db_name" json-data)
          :server (gethash "db_host_local" json-data)
          :port (let ((port-value (gethash "db_port_local" json-data)))
                  (if (stringp port-value) 
                      (string-to-number port-value) 
                    port-value))
          :password (gethash "db_password" json-data))))

;; Direct PostgreSQL connection function
(defun my/postgres-connect ()
  "Connect to PostgreSQL using settings from secrets file."
  (interactive)
  ;; Get connection details
  (let* ((pg-conn (my/read-postgres-secrets))
         (sql-postgres-program "psql")
         (sql-postgres-options '("-P" "pager=off"))
         (sql-product 'postgres)
         (sql-user (plist-get pg-conn :user))
         (sql-password (plist-get pg-conn :password))
         (sql-server (plist-get pg-conn :server))
         (sql-database (plist-get pg-conn :database))
         (sql-port (plist-get pg-conn :port)))
    
    ;; Create a buffer name based on connection details
    (let ((sql-buffer (sql-postgres)))
      ;; After connection, set up buffer for SQL sending
      (with-current-buffer sql-buffer
        (setq-local sql-buffer sql-buffer))
      
      ;; Return to the previous buffer and set sql-buffer there too
      (with-current-buffer (other-buffer sql-buffer 1)
        (when (eq major-mode 'sql-mode)
          (setq-local sql-buffer sql-buffer))))))

;; Setup SQL file keybindings
(with-eval-after-load 'sql
  (define-key sql-mode-map (kbd "C-c C-c") 'sql-send-paragraph))

(defun my/copy-pg-password-to-kill-ring ()
  "Copy PostgreSQL password from secrets to the kill ring."
  (interactive)
  (let* ((pg-conn (my/read-postgres-secrets))
         (password (plist-get pg-conn :password)))
    (kill-new password)
    (message "PostgreSQL password copied to clipboard. Use yank (C-y) to paste it.")))

;; Bind to a convenient key combination
(global-set-key (kbd "C-c s c") 'my/postgres-connect)
(global-set-key (kbd "C-c s p") 'my/copy-pg-password-to-kill-ring)

;; Configure which-key to show a descriptive prefix for your SQL keys
(which-key-add-key-based-replacements
  "C-c s" "sql")

;; You can also add descriptions for the individual commands
(which-key-add-key-based-replacements
  "C-c s c" "connect"
  "C-c s p" "copy password")
#+end_src
